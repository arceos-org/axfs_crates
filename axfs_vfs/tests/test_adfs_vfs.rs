// tests/test_axfs_vfs.rs

// Import all public components from the axfs_vfs crate
use axfs_vfs::{
    impl_vfs_dir_default, impl_vfs_non_dir_default, path, VfsError, VfsNodeAttr, VfsNodeOps,
    VfsNodePerm, VfsNodeType, VfsResult,
};
use std::sync::Arc;

// =================================================================
// Test Case 1: Validate data structures (from structs.rs)
// =================================================================
#[test]
fn test_vfs_data_structures() {
    println!("\n--- Test Case 1: Validating VFS Data Structures ---");

    // Test VfsNodeAttr (node attributes)
    let file_attr = VfsNodeAttr::new_file(1024, 2);
    assert_eq!(file_attr.is_file(), true, "Should be identified as a file");
    assert_eq!(
        file_attr.is_dir(),
        false,
        "Should not be identified as a directory"
    );
    assert_eq!(file_attr.size(), 1024, "File size should be 1024");
    assert_eq!(file_attr.file_type(), VfsNodeType::File);

    let dir_attr = VfsNodeAttr::new_dir(4096, 8);
    assert_eq!(
        dir_attr.is_dir(),
        true,
        "Should be identified as a directory"
    );
    // Now that VfsNodePerm implements PartialEq, this line works correctly
    assert_eq!(
        dir_attr.perm(),
        VfsNodePerm::default_dir(),
        "Permissions should be the default for a directory"
    );

    // Test VfsNodePerm (node permissions)
    let perm = VfsNodePerm::from_bits_truncate(0o755); // rwxr-xr-x
    assert!(perm.owner_readable() && perm.owner_writable() && perm.owner_executable());

    // Fix: Use .contains() to check group and other permissions
    assert!(
        perm.contains(VfsNodePerm::GROUP_READ)
            && !perm.contains(VfsNodePerm::GROUP_WRITE)
            && perm.contains(VfsNodePerm::GROUP_EXEC)
    );
    assert!(
        perm.contains(VfsNodePerm::OTHER_READ)
            && !perm.contains(VfsNodePerm::OTHER_WRITE)
            && perm.contains(VfsNodePerm::OTHER_EXEC)
    );

    assert_eq!(
        perm.rwx_buf(),
        *b"rwxr-xr-x",
        "rwx string representation should be correct"
    );

    // Test VfsNodeType (node type)
    assert_eq!(
        VfsNodeType::Dir.as_char(),
        'd',
        "Character representation for Dir type should be 'd'"
    );
    assert_eq!(
        VfsNodeType::File.as_char(),
        '-',
        "Character representation for File type should be '-'"
    );

    println!("--- Test Case 1 Passed ---");
}

// =================================================================
// Test Case 2: Validate path utilities (from path.rs)
// =================================================================
#[test]
fn test_path_canonicalization() {
    println!("\n--- Test Case 2: Validating Path Canonicalization ---");

    // Complex absolute path containing '.', '..', and extra slashes
    assert_eq!(
        path::canonicalize("/a/b/./c/../d//e"),
        "/a/b/d/e",
        "Canonicalization of a complex absolute path failed"
    );

    // Absolute path that traverses up to the root
    assert_eq!(
        path::canonicalize("/a/b/../../c"),
        "/c",
        "Canonicalization of an absolute path traversing to root failed"
    );

    // Relative path
    assert_eq!(
        path::canonicalize("a/b/../c"),
        "a/c",
        "Canonicalization of a relative path failed"
    );

    // Edge cases: root directory and empty path
    assert_eq!(
        path::canonicalize("///"),
        "/",
        "Canonicalization of the root directory path failed"
    );
    assert_eq!(
        path::canonicalize(""),
        "",
        "An empty path should remain empty"
    );

    println!("--- Test Case 2 Passed ---");
}

// =================================================================
// Test Case 3: Validate default implementations generated by macros (from macros.rs)
// =================================================================
#[test]
fn test_default_impl_macros() {
    println!("\n--- Test Case 3: Validating Macro Default Implementations ---");

    // Define a mock "file" node type
    struct MockFileNode;
    impl VfsNodeOps for MockFileNode {
        fn get_attr(&self) -> VfsResult<VfsNodeAttr> {
            Ok(VfsNodeAttr::new_file(0, 0))
        }
        impl_vfs_non_dir_default!();
    }

    // Define a mock "directory" node type
    struct MockDirNode;
    impl VfsNodeOps for MockDirNode {
        fn get_attr(&self) -> VfsResult<VfsNodeAttr> {
            Ok(VfsNodeAttr::new_dir(0, 0))
        }
        impl_vfs_dir_default!();
    }

    let file_node: Arc<dyn VfsNodeOps> = Arc::new(MockFileNode);
    let dir_node: Arc<dyn VfsNodeOps> = Arc::new(MockDirNode);

    // Verify: Calling a directory operation on a "file" node should return NotADirectory
    assert_eq!(
        file_node.clone().lookup("any").err(),
        Some(VfsError::NotADirectory)
    );
    assert_eq!(
        file_node.create("any", VfsNodeType::File).err(),
        Some(VfsError::NotADirectory)
    );

    // Verify: Calling a file operation on a "directory" node should return IsADirectory
    let mut buffer = [0u8; 8];
    assert_eq!(
        dir_node.read_at(0, &mut buffer).err(),
        Some(VfsError::IsADirectory)
    );
    assert_eq!(
        dir_node.write_at(0, &buffer).err(),
        Some(VfsError::IsADirectory)
    );

    println!("--- Test Case 3 Passed ---");
}
